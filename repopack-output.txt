================================================================
REPOPACK OUTPUT FILE
================================================================

This file was generated by Repopack on: 2024-07-15T14:30:09.940Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Multiple file entries, each consisting of:
   a. A separator line (================)
   b. The file path (File: path/to/file)
   c. Another separator line
   d. The full contents of the file
   e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
   original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
   distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
   the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Files
================================================================

================
File: .editorconfig
================
root = true

[*.*]
indent_style = space
indent_size = 2
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true
end_of_line = lf
max_line_length = null

================
File: .github/workflows/build.yml
================
name: Build Extensions

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:

  build:
    runs-on: ubuntu-22.04
    timeout-minutes: 20
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        lfs: true

    - name: Setup node
      uses: actions/setup-node@v4
      with:
        node-version-file: .tool-versions
        cache: yarn

    - name: Install dependencies
      run: yarn install

    - name: Build Chrome Extension
      run: yarn build chrome

    - name: Build Firefox Extension
      run: yarn build firefox

    - name: Build Edge Extension
      run: yarn build edge

    - name: Build Opera Extension
      run: yarn build opera

    - name: Build Safari Extension
      run: yarn build safari

    - name: Archive packages
      uses: actions/upload-artifact@v4
      with:
        name: packages
        path: packages

================
File: .github/workflows/test.yml
================
name: Test

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  lint:
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup node
      uses: actions/setup-node@v4
      with:
        node-version-file: .tool-versions
        cache: yarn

    - name: Install dependencies
      run: yarn install

    - name: Run type check
      run: yarn type-check

    - name: Lint
      run: yarn lint

  test:
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup node
      uses: actions/setup-node@v4
      with:
        node-version-file: .tool-versions
        cache: yarn

    - name: Install dependencies
      run: yarn install

    - name: Test
      run: yarn test

================
File: .node-version
================
20.15.0

================
File: .tool-versions
================
nodejs 20.15.0

================
File: .webextensiontoolboxrc
================
src: app
target: dist/[vendor]
devtool: cheap-source-map
manifestValidation: true
minimize: true
config: webextension-toolbox.config.js

================
File: .yarnclean
================
# test directories
__tests__
test
tests
powered-test

# asset directories
docs
doc
website
images
assets

# examples
example
examples

# code coverage directories
coverage
.nyc_output

# build scripts
Makefile
Gulpfile.js
Gruntfile.js

# configs
appveyor.yml
circle.yml
codeship-services.yml
codeship-steps.yml
wercker.yml
.tern-project
.gitattributes
.editorconfig
.*ignore
.eslintrc
.jshintrc
.flowconfig
.documentup.json
.yarn-metadata.json
.travis.yml

# misc
*.md

================
File: .yarnrc.yml
================
compressionLevel: mixed

enableGlobalCache: false

nodeLinker: node-modules

yarnPath: .yarn/releases/yarn-4.3.1.cjs

================
File: LICENSE
================
Copyright 2023 Kazuki Yamada

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

================
File: README.md
================
# <img src="app/images/icon-128.png" height=26> Slack Channels Grouping

Grouping slack channels.

![](./promo/Screenshot_1280x800.png)

[![Chrome Users](https://img.shields.io/chrome-web-store/users/lcbnhfianneihfgkmfncnhpkpghedbkm?logo=google-chrome&logoColor=white)](https://chrome.google.com/webstore/detail/slack-channels-grouping/lcbnhfianneihfgkmfncnhpkpghedbkm)   [![Firefox Users](https://img.shields.io/amo/users/slack-channels-grouping?logo=firefox&color=blightcreen)](https://addons.mozilla.org/firefox/addon/slack-channels-grouping/)   [![Chrome Web Store](https://img.shields.io/chrome-web-store/v/lcbnhfianneihfgkmfncnhpkpghedbkm?logo=google-chrome&logoColor=white)](https://chrome.google.com/webstore/detail/slack-channels-grouping/lcbnhfianneihfgkmfncnhpkpghedbkm)   [![Mozilla Add-on](https://img.shields.io/amo/v/slack-channels-grouping?logo=firefox)](https://addons.mozilla.org/ja/firefox/addon/slack-channels-grouping/)


## Install

- Chrome: [Slack Channels Grouping - Chrome Web Store](https://chrome.google.com/webstore/detail/slack-channels-grouping/lcbnhfianneihfgkmfncnhpkpghedbkm)
- Firefox: [Slack Channels Grouping – Firefox Add-ons](https://addons.mozilla.org/firefox/addon/slack-channels-grouping/)
- Opera: [Slack Channels Grouping extension - Opera add-ons](https://addons.opera.com/extensions/details/slack-channels-grouping)
- Edge: [Slack Channels Grouping – Microsoft Edge Addons](https://microsoftedge.microsoft.com/addons/detail/klpmclmecincfgkoebkackfkmkafpgml)

## Supported Languages
- `de` German
- `el` Greek
- `en` English
- `es` Spanish
- `fr` French
- `it` Italian
- `ja` Japanese
- `ko` Korean
- `nl` Dutch
- `pt_BR` Portuguese - BRAZIL
- `pt_PT` Portuguese
- `ru` Russian
- `zh_CN` Chinese - Simplified
- `zh_TW` Chinese - Traditional

## Development
- Node.js >= v18

### Setup
```
$ yarn
```

### Watch and build
```
yarn dev chrome
yarn dev firefox
yarn dev opera
yarn dev edge
yarn dev safari
```

### Build extension
```
yarn build chrome
yarn build firefox
yarn build opera
yarn build edge
yarn build safari
```

### Lint codes
Lint only.
```
yarn lint
```

Lint codes with fix.
```
yarn lint:fix
```

### Type Checking
```
yarn type-check
```

### Generate font file for Box-drawing character
```
pip install fonttools
```

```
cd ./tools/font-builder
. build.sh
```

### Show supported browsers
```
yarn supported-browsers
```

## LICENSE
MIT

================
File: app/_locales/de/detailed-description.txt
================
Diese Erweiterung gruppiert Slack-Kanäle nach Präfixen, wodurch es einfacher wird, Kanäle visuell zu finden.
Es unterstützt sowohl Bindestriche (-) als auch Unterstriche (_), sodass Sie Kanäle mit Namen wie folgt gruppieren können:
• präfix-name
• präfix_name

Es werden keine Informationen von Slack oder anderen Daten an Entwickler oder Dritte übermittelt oder veröffentlicht.

Der Quellcode ist ebenfalls verfügbar, sodass Sie ihn selbst erstellen und installieren können.
Weitere Informationen finden Sie unter:
https://github.com/yamadashy/slack-channels-grouping

================
File: app/_locales/de/messages.json
================
{
  "appDescription": {
    "message": "Es gruppiert Slack-Kanäle nach Präfix."
  }
}

================
File: app/_locales/en/detailed-description.txt
================
This extension groups Slack channels by prefix, making it easier to find channels visually.
It supports both hyphens (-) and underscores (_), allowing you to group channels with names like:
• prefix-name
• prefix_name

No information from Slack or other data is transmitted or disclosed to developers or third parties.

The source code is also available, so you can build and install it yourself.
For more information, please visit:
https://github.com/yamadashy/slack-channels-grouping

================
File: app/_locales/en/messages.json
================
{
  "appDescription": {
    "message": "It grouping Slack channels by prefix."
  }
}

================
File: app/_locales/es/detailed-description.txt
================
Cette extension regroupe les canaux Slack par préfixe, ce qui facilite la recherche visuelle des canaux.
Elle prend en charge les traits d'union (-) et les traits de soulignement (_), vous permettant de regrouper les canaux avec des noms comme:
• préfixe-nom
• préfixe_nom

No se transmite ni divulga ninguna información de Slack ni otros datos a los desarrolladores ni a terceros.

Le code source est également disponible, vous pouvez donc le construire et l'installer vous-même.
Pour plus d'informations, veuillez visiter:
https://github.com/yamadashy/slack-channels-grouping

================
File: app/_locales/es/messages.json
================
{
  "appDescription": {
    "message": "Agrupa los canales de Slack por prefijo."
  }
}

================
File: app/_locales/fr/detailed-description.txt
================
Cette extension regroupe les canaux Slack par préfixe, ce qui facilite la recherche visuelle des canaux.
Elle prend en charge les traits d'union (-) et les traits de soulignement (_), vous permettant de regrouper les canaux avec des noms comme:
• préfixe-nom
• préfixe_nom

Aucune information de Slack ou autre donnée n'est transmise ou divulguée aux développeurs ou à des tiers.

Le code source est également disponible, vous pouvez donc le construire et l'installer vous-même.
Pour plus d'informations, veuillez visiter:
https://github.com/yamadashy/slack-channels-grouping

================
File: app/_locales/fr/messages.json
================
{
  "appDescription": {
    "message": "Il regroupe les canaux Slack par préfixe."
  }
}

================
File: app/_locales/hi/messages.json
================
{
  "appDescription": {
    "message": "It grouping Slack channels by prefix."
  }
}

================
File: app/_locales/it/detailed-description.txt
================
Questa estensione raggruppa i canali Slack per prefisso, rendendo più facile trovare visivamente i canali.
Supporta sia i trattini (-) che i trattini bassi (_), consentendo di raggruppare i canali con nomi come:
• prefisso-nome
• prefisso_nome

Nessuna informazione da Slack o altri dati viene trasmessa o divulgata agli sviluppatori o a terzi.

Il codice sorgente è disponibile, in modo da poterlo costruire e installare da soli.
Per ulteriori informazioni, visitare:
https://github.com/yamadashy/slack-channels-grouping

================
File: app/_locales/it/messages.json
================
{
  "appDescription": {
    "message": "Raggruppa i canali Slack per prefisso."
  }
}

================
File: app/_locales/nl/detailed-description.txt
================
Deze extensie groepeert Slack-kanalen op basis van voorvoegsel, waardoor het gemakkelijker wordt om kanalen visueel te vinden.
Het ondersteunt zowel afbreekstreepjes (-) als onderstrepingstekens (_), zodat je kanalen met namen als volgt kunt groeperen:
• voorvoegsel-naam
• voorvoegsel_naam

Er wordt geen informatie van Slack of andere gegevens naar ontwikkelaars of derden verzonden of openbaar gemaakt.

De broncode is ook beschikbaar, zodat je het zelf kunt bouwen en installeren.
Voor meer informatie, bezoek:
https://github.com/yamadashy/slack-channels-grouping

================
File: app/_locales/nl/messages.json
================
{
  "appDescription": {
    "message": "Het groepeert Slack-kanalen op prefix."
  }
}

================
File: app/_locales/pt_BR/detailed-description.txt
================
Esta extensão agrupa os canais do Slack por prefixo, tornando mais fácil encontrar os canais visualmente.
Ela suporta tanto hifens (-) quanto sublinhados (_), permitindo que você agrupe canais com nomes como:
• prefixo-nome
• prefixo_nome

Nenhuma informação do Slack ou outros dados são transmitidos ou divulgados a desenvolvedores ou terceiros.

O código-fonte também está disponível, para que você possa compilar e instalar por conta própria.
Para mais informações, por favor, visite:
https://github.com/yamadashy/slack-channels-grouping

================
File: app/_locales/pt_BR/messages.json
================
{
  "appDescription": {
    "message": "Agrupando canais Slack por prefixo."
  }
}

================
File: app/_locales/pt_PT/detailed-description.txt
================
Esta extensão agrupa os canais do Slack por prefixo, tornando mais fácil encontrar os canais visualmente.
Suporta tanto hífenes (-) como sublinhados (_), permitindo-lhe agrupar canais com nomes como:
• prefixo-nome
• prefixo_nome

Nenhuma informação do Slack ou outros dados são transmitidos ou divulgados a desenvolvedores ou terceiros.

O código fonte também está disponível, para que possa compilar e instalar você mesmo.
Para mais informações, por favor, visite:
https://github.com/yamadashy/slack-channels-grouping

================
File: app/_locales/pt_PT/messages.json
================
{
  "appDescription": {
    "message": "Agrupando canais Slack por prefixo."
  }
}

================
File: app/fonts/OFL.txt
================
Copyright 2012 Google Inc. All Rights Reserved.

This Font Software is licensed under the SIL Open Font License, Version 1.1.
This license is copied below, and is also available with a FAQ at:
http://scripts.sil.org/OFL


-----------------------------------------------------------
SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
-----------------------------------------------------------

PREAMBLE
The goals of the Open Font License (OFL) are to stimulate worldwide
development of collaborative font projects, to support the font creation
efforts of academic and linguistic communities, and to provide a free and
open framework in which fonts may be shared and improved in partnership
with others.

The OFL allows the licensed fonts to be used, studied, modified and
redistributed freely as long as they are not sold by themselves. The
fonts, including any derivative works, can be bundled, embedded, 
redistributed and/or sold with any software provided that any reserved
names are not used by derivative works. The fonts and derivatives,
however, cannot be released under any other type of license. The
requirement for fonts to remain under this license does not apply
to any document created using the fonts or their derivatives.

DEFINITIONS
"Font Software" refers to the set of files released by the Copyright
Holder(s) under this license and clearly marked as such. This may
include source files, build scripts and documentation.

"Reserved Font Name" refers to any names specified as such after the
copyright statement(s).

"Original Version" refers to the collection of Font Software components as
distributed by the Copyright Holder(s).

"Modified Version" refers to any derivative made by adding to, deleting,
or substituting -- in part or in whole -- any of the components of the
Original Version, by changing formats or by porting the Font Software to a
new environment.

"Author" refers to any designer, engineer, programmer, technical
writer or other person who contributed to the Font Software.

PERMISSION & CONDITIONS
Permission is hereby granted, free of charge, to any person obtaining
a copy of the Font Software, to use, study, copy, merge, embed, modify,
redistribute, and sell modified and unmodified copies of the Font
Software, subject to the following conditions:

1) Neither the Font Software nor any of its individual components,
in Original or Modified Versions, may be sold by itself.

2) Original or Modified Versions of the Font Software may be bundled,
redistributed and/or sold with any software, provided that each copy
contains the above copyright notice and this license. These can be
included either as stand-alone text files, human-readable headers or
in the appropriate machine-readable metadata fields within text or
binary files as long as those fields can be easily viewed by the user.

3) No Modified Version of the Font Software may use the Reserved Font
Name(s) unless explicit written permission is granted by the corresponding
Copyright Holder. This restriction only applies to the primary font name as
presented to the users.

4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font
Software shall not be used to promote, endorse or advertise any
Modified Version, except to acknowledge the contribution(s) of the
Copyright Holder(s) and the Author(s) or with their explicit written
permission.

5) The Font Software, modified or unmodified, in part or in whole,
must be distributed entirely under this license, and must not be
distributed under any other license. The requirement for fonts to
remain under this license does not apply to any document created
using the Font Software.

TERMINATION
This license becomes null and void if any of the above conditions are
not met.

DISCLAIMER
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
OTHER DEALINGS IN THE FONT SOFTWARE.

================
File: app/manifest.json
================
{
  "name": "Slack Channels Grouping",
  "short_name": "slack-ch-grp",
  "description": "__MSG_appDescription__",
  "version": "1.0.39",
  "manifest_version": 3,
  "default_locale": "en",
  "icons": {
    "16": "images/icon-16.png",
    "19": "images/icon-19.png",
    "32": "images/icon-32.png",
    "38": "images/icon-38.png",
    "48": "images/icon-48.png",
    "64": "images/icon-64.png",
    "128": "images/icon-128.png"
  },
  "minimum_chrome_version": "88.0",
  "content_scripts": [
    {
      "matches": [
        "http://app.slack.com/*",
        "https://app.slack.com/*"
      ],
      "css": [
        "styles/font-face.css",
        "styles/content.css"
      ],
      "__firefox__css": [
        "styles/font-face-firefox.css",
        "styles/content.css"
      ],
      "js": [
        "scripts/content.js"
      ],
      "run_at": "document_start",
      "all_frames": true
    }
  ],
  "action": {
    "default_popup": "pages/popup.html",
    "default_icon": {
      "16": "images/icon-16.png",
      "48": "images/icon-48.png",
      "128": "images/icon-128.png"
    }
  },
  "background": {
    "service_worker": "scripts/background.js"
  },
  "permissions": [
    "scripting",
    "storage",
    "activeTab"
  ],
  "web_accessible_resources": [
    {
      "resources": [
        "fonts/SlackChannelsGrounping-NotoSansJP-Medium.ttf"
      ],
      "matches": [
        "http://app.slack.com/*",
        "https://app.slack.com/*"
      ]
    }
  ],

  "__chrome|opera|edge|safari__host_permissions": [
    "http://app.slack.com/*",
    "https://app.slack.com/*"
  ],

  "__firefox__manifest_version": 2,
  "__firefox__background": {
    "scripts": [
      "scripts/background.js"
    ]
  },
  "__firefox__permissions": [
    "scripting",
    "storage",
    "activeTab",
    "http://app.slack.com/*",
    "https://app.slack.com/*"
  ],
  "__firefox__web_accessible_resources": [
    "fonts/SlackChannelsGrounping-NotoSansJP-Medium.ttf"
  ],
  "__firefox__browser_specific_settings": {
    "gecko": {
      "id": "{24d54390-97ea-4c57-b4be-7e32232ca609}",
      "strict_min_version": "102.0"
    }
  }
}

================
File: app/pages/popup.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slack Channels Grouping Settings</title>
</head>
<body>
    <div id="root"></div>
    <script src="../scripts/popup/index.js"></script>
</body>
</html>

================
File: app/scripts/background.ts
================
const injectContentToTab = async (tab: chrome.tabs.Tab) => {
  // Do not have permission
  if (tab.url === undefined) {
    return;
  }

  // Skip execute on discarded tab
  if (tab.discarded) {
    return;
  }

  // Under some circumstances a Tab may not be assigned an ID
  if (tab.id === undefined) {
    return;
  }

  const manifest = chrome.runtime.getManifest();
  const cssFiles = manifest.content_scripts?.[0].css ?? [];
  const jsFiles = manifest.content_scripts?.[0].js ?? [];

  if (cssFiles.length > 0) {
    await chrome.scripting.insertCSS({
      target: {
        tabId: tab.id,
        allFrames: true,
      },
      files: cssFiles,
    });
  }
  if (jsFiles.length > 0) {
    await chrome.scripting.executeScript({
      target: {
        tabId: tab.id,
        allFrames: true,
      },
      files: jsFiles,
    });
  }
};

// Update extension content for tabs
chrome.tabs.query({}, async (tabs) => {
  for (const tabKey in tabs) {
    const tab = tabs[tabKey];

    try {
      injectContentToTab(tab);
    } catch (e) {
      console.error(e);
    }
  }
});

let contentScriptReady = false;

chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === 'getWorkspaceId') {
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      const currentTab = tabs[0];
      console.log(currentTab);
      console.log(currentTab.url);
      if (currentTab && currentTab.url) {
        const match = currentTab.url.match(/https:\/\/app\.slack\.com\/client\/([^/]+)/);
        const workspaceId = match ? match[1] : null;
        sendResponse({ workspaceId: workspaceId });
      } else {
        sendResponse({ workspaceId: null });
      }
    });
    return true;
  }

  if (request.action === 'contentScriptReady') {
    contentScriptReady = true;
    console.log('Content script is ready');
    sendResponse({ received: true });
    return false;
  }

  if (request.action === 'settingsUpdated') {
    if (!contentScriptReady) {
      console.log('Content script not ready');
      sendResponse({ success: false, error: 'Content script not ready' });
      return false;
    }

    console.log('Notifying content script about settings update');
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      if (tabs[0] && tabs[0].id) {
        chrome.tabs.sendMessage(tabs[0].id, { action: 'settingsUpdated' }, (response) => {
          if (chrome.runtime.lastError) {
            console.error('Error sending message:', chrome.runtime.lastError);
            sendResponse({ success: false, error: chrome.runtime.lastError.message });
          } else {
            console.log('Settings update notification sent successfully, response:', response);
            sendResponse(response);
          }
        });
      } else {
        console.log('No active tab found');
        sendResponse({ success: false, error: 'No active tab found' });
      }
    });
    return true; // Needed for asynchronous response
  }
});

console.log('Background script loaded');

================
File: app/scripts/content/channel-grouper.ts
================
import 'requestidlecallback-polyfill';
import { logger } from './logger';
import {
  ChannelItemContext,
  ChannelItemContextGroupType,
  ChannelManipulator,
  GroupedChannelItemContext,
} from './channel-manipulators/channel-manipulator';

// constants
const GROUPING_IDLE_CALLBACK_TIMEOUT = 3 * 1000;
const UPDATE_CHANNEL_LIST_MIN_INTERVAL = 200;
const CHANNEL_NAME_ROOT = '-/';

/**
 * Channel Grouping Class
 */
export default class ChannelGrouper {
  private debounceEmitUpdateTimeoutId: number | null;
  private idleCallbackId: number | null;
  private multiLevelGrouping: boolean;

  constructor(private readonly adapter: ChannelManipulator) {
    this.debounceEmitUpdateTimeoutId = null;
    this.idleCallbackId = null;
    this.multiLevelGrouping = false;

    this.loadSettingsFromStorage();

    // Set up message listener
    chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
      if (request.action === 'settingsUpdated') {
        this.loadSettingsFromStorage();
        sendResponse({ success: true });
      }
      return true; // Needed for asynchronous response
    });
  }

  private loadSettingsFromStorage(): void {
    chrome.storage.local.get(['multiLevelGrouping'], (result) => {
      if (result.multiLevelGrouping !== undefined) {
        this.multiLevelGrouping = result.multiLevelGrouping;
        this.groupingOnIdleAndDebounce();
      }
    });
  }

  groupingOnIdleAndDebounce(): void {
    if (this.debounceEmitUpdateTimeoutId !== null) {
      window.clearTimeout(this.debounceEmitUpdateTimeoutId);
    }

    // Reduce infinity loop impact
    this.debounceEmitUpdateTimeoutId = window.setTimeout(() => {
      if (this.idleCallbackId !== null) {
        window.cancelIdleCallback(this.idleCallbackId);
      }

      this.idleCallbackId = window.requestIdleCallback(
        () => {
          this.grouping();
        },
        {
          timeout: GROUPING_IDLE_CALLBACK_TIMEOUT,
        },
      );
    }, UPDATE_CHANNEL_LIST_MIN_INTERVAL);
  }

  public grouping(): GroupedChannelItemContext[] | null {
    logger.labeledLog('Grouping all by prefix');

    let channelItemContexts = this.adapter.getChannelItemContexts();
    if (!channelItemContexts) {
      return null;
    }

    const groupedChannelItemContext = this.applyGroupingToContexts(channelItemContexts);

    logger.labeledLog('Grouped channelItemContexts:', groupedChannelItemContext);

    this.adapter.persistGroupedChannelItemContexts(groupedChannelItemContext);

    this.adapter.updateChannelItems(groupedChannelItemContext);

    return groupedChannelItemContext;
  }

  private applyGroupingToContexts(channelItemContexts: ChannelItemContext[]): GroupedChannelItemContext[] {
    let prefixMap = new Map<number, string[]>();

    // Get prefix map
    for (const context of channelItemContexts) {
      const prefixes = context.name.split(/[-_]/);
      prefixMap.set(context.index, prefixes);
    }

    // Grouping
    return channelItemContexts.map((context, index): GroupedChannelItemContext => {
      const currentPrefixes = prefixMap.get(index) ?? [];
      const prevPrefixes = prefixMap.get(index - 1) ?? [];
      const nextPrefixes = prefixMap.get(index + 1) ?? [];

      let groupType: ChannelItemContextGroupType;
      let prefix: string | null = null;

      // If channelItemType is 'im' or 'mpim', skip grouping
      if (context.channelItemType === 'im' || context.channelItemType === 'mpim') {
        return {
          ...context,
          prefix: null,
          groupType: ChannelItemContextGroupType.Alone,
        };
      }

      if (this.multiLevelGrouping) {
        const commonPrefixLength = this.getCommonPrefixLength(currentPrefixes, prevPrefixes, nextPrefixes);
        prefix = currentPrefixes.slice(0, commonPrefixLength).join('-');

        if (commonPrefixLength === 0) {
          groupType = ChannelItemContextGroupType.Alone;
        } else if (this.getCommonPrefixLength(currentPrefixes, prevPrefixes, nextPrefixes) < commonPrefixLength) {
          groupType = ChannelItemContextGroupType.Parent;
        } else if (this.getCommonPrefixLength(currentPrefixes, nextPrefixes, nextPrefixes) < commonPrefixLength) {
          groupType = ChannelItemContextGroupType.LastChild;
        } else {
          groupType = ChannelItemContextGroupType.Child;
        }
      } else {
        // Original single-level grouping logic
        prefix = currentPrefixes[0] ?? null;
        if (prefix === null || (prefix !== prevPrefixes[0] && prefix !== nextPrefixes[0])) {
          groupType = ChannelItemContextGroupType.Alone;
        } else if (prefix !== prevPrefixes[0] && prefix === nextPrefixes[0]) {
          groupType = ChannelItemContextGroupType.Parent;
        } else if (prefix !== nextPrefixes[0]) {
          groupType = ChannelItemContextGroupType.LastChild;
        } else {
          groupType = ChannelItemContextGroupType.Child;
        }
      }

      return {
        ...context,
        prefix,
        groupType,
      };
    });
  }

  private getCommonPrefixLength(current: string[], prev: string[], next: string[]): number {
    let length = 0;
    while (
      length < current.length &&
      ((length < prev.length && current[length] === prev[length]) ||
        (length < next.length && current[length] === next[length]))
    ) {
      length++;
    }
    return length;
  }
}

================
File: app/scripts/content/channel-manipulators/channel-manipulator.ts
================
export enum ChannelItemContextGroupType {
  Parent = 'parent',
  Child = 'child',
  LastChild = 'lastChild',
  Alone = 'alone',
}

export type ChannelItemType = 'channel' | 'private' | 'im' | 'mpim';

export interface ChannelItemContext {
  index: number;
  name: string;
  channelItemType: ChannelItemType | null;
}

export interface GroupedChannelItemContext extends ChannelItemContext {
  prefix: string | null;
  groupType: ChannelItemContextGroupType;
}

export interface ChannelManipulator {
  getChannelItemContexts(): ChannelItemContext[];
  persistGroupedChannelItemContexts(channelItemContexts: GroupedChannelItemContext[]): void;
  updateChannelItems(channelItemContexts: GroupedChannelItemContext[]): void;
}

================
File: app/scripts/content/channel-manipulators/dom-channel-manipulator.ts
================
import {
  DATA_KEY_CHANNEL_ITEM_CONTENTS_CONTAINER_CHANNEL_TYPE,
  DATA_KEY_CHANNEL_NAME,
  SELECTOR_CHANNEL_ITEM_CONTENTS_CONTAINER,
  SELECTOR_CHANNEL_ITEM_NAME_SELECTOR,
  SELECTOR_CHANNEL_LIST_ITEMS,
} from '../dom-constants';
import $ from 'jquery/dist/jquery.slim';
import {
  ChannelItemContext,
  ChannelItemContextGroupType,
  ChannelItemType,
  ChannelManipulator,
  GroupedChannelItemContext,
} from './channel-manipulator';
import { logger } from '../logger';

export class DomChannelManipulator implements ChannelManipulator {
  public getChannelItemContexts(): ChannelItemContext[] {
    const $channelItems = $(SELECTOR_CHANNEL_LIST_ITEMS);

    const channelItemContexts = Array.from($channelItems).map((channelItemElement, index): ChannelItemContext => {
      const $channelName = $(channelItemElement).find(SELECTOR_CHANNEL_ITEM_NAME_SELECTOR);
      const $channelContentsContainer = $(channelItemElement).find(SELECTOR_CHANNEL_ITEM_CONTENTS_CONTAINER);
      const dataChannelItemType = $channelContentsContainer.attr(DATA_KEY_CHANNEL_ITEM_CONTENTS_CONTAINER_CHANNEL_TYPE);
      const channelItemType = (dataChannelItemType ?? null) as ChannelItemType;
      const isAlreadyApplied = $channelName.find('span.scg').length > 0;
      let channelName: string;

      // Get ch name
      if (isAlreadyApplied && $channelName.data(DATA_KEY_CHANNEL_NAME)) {
        channelName = $channelName.data(DATA_KEY_CHANNEL_NAME);
      } else {
        channelName = $channelName.text().trim();
      }

      return {
        index,
        name: channelName,
        channelItemType,
      };
    });

    return channelItemContexts;
  }

  public persistGroupedChannelItemContexts(channelItemContexts: GroupedChannelItemContext[]): void {
    const $channelItems = $(SELECTOR_CHANNEL_LIST_ITEMS);

    channelItemContexts.forEach((context, index) => {
      const $channelName = $channelItems.eq(index).find(SELECTOR_CHANNEL_ITEM_NAME_SELECTOR);
      $channelName.data(DATA_KEY_CHANNEL_NAME, context.name);
    });
  }

  public updateChannelItems(channelItemContexts: GroupedChannelItemContext[]): void {
    const $channelItems = $(SELECTOR_CHANNEL_LIST_ITEMS);

    $channelItems.each((index: number, channelItem: HTMLElement) => {
      const context = channelItemContexts[index];
      const $channelName = $(channelItem).find(SELECTOR_CHANNEL_ITEM_NAME_SELECTOR);
      const channelItemType = context.channelItemType;
      const prefix: string | null = context.prefix;
      const isParent = context.groupType === ChannelItemContextGroupType.Parent;
      const isLastChild = context.groupType === ChannelItemContextGroupType.LastChild;
      let separator = '';

      // Skip direct message
      if (channelItemType === 'im') {
        return;
      }

      // Skip blank item
      if ($channelName.length === 0) {
        return;
      }

      // reset
      // $channelName.removeClass('scg-ch-parent scg-ch-child').text(context.name);

      // Skip no prefix
      if (prefix === null) {
        return;
      }

      // TODO: 戻したらやりなおすように
      // TODO: ON/OFFできる？
      if (context.groupType === ChannelItemContextGroupType.Alone) {
        $channelName.removeClass('scg-ch-parent scg-ch-child').text(context.name);
      } else {
        let separatorPseudoClass: string;

        if (isParent) {
          separator = '┬';
          separatorPseudoClass = 'scg-ch-separator-pseudo-bottom';
        } else if (isLastChild) {
          separator = '└';
          separatorPseudoClass = 'scg-ch-separator-pseudo-top';
        } else {
          separator = '├';
          separatorPseudoClass = 'scg-ch-separator-pseudo-both';
        }

        // Skip no changed
        if (separator === $channelName.find('.scg-ch-separator').text()) {
          return;
        }

        $channelName
          .removeClass('scg scg-ch-parent scg-ch-child')
          .addClass(isParent ? 'scg scg-ch-parent' : 'scg scg-ch-child')
          .empty()
          .append([
            $('<span>')
              .addClass('scg scg-ch-prefix')
              .text(prefix ?? ''),
            $('<span>')
              .addClass('scg scg-ch-separator ' + separatorPseudoClass)
              .text(separator),
            $('<span>')
              .addClass('scg scg-ch-name')
              .text(context.name.replace(/(^.+?)[-_](.*)/, '$2')),
          ]);
      }
    });
  }
}

================
File: app/scripts/content/channel-observer.ts
================
// modules
import { EventEmitter } from 'eventemitter3';
import * as domConstants from './dom-constants';
import { logger } from './logger';

/**
 * Channel Observing Class
 * @extends EventEmitter
 */
export default class ChannelObserver extends EventEmitter<'update'> {
  private isObserving: boolean;
  private channelListObserver: MutationObserver;

  constructor() {
    super();
    this.isObserving = false;
    this.channelListObserver = new MutationObserver((mutations): void => {
      logger.labeledLog('Observed channel dom change');

      // Observe added channel list item
      mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((addedNode) => {
          if (addedNode instanceof HTMLElement) {
            const channelListItemNameElem = addedNode.querySelector(domConstants.SELECTOR_CHANNEL_ITEM_NAME_SELECTOR);
            if (channelListItemNameElem !== null) {
              this.observeChannelListItemName(channelListItemNameElem);
            }
          }
        });
      });

      // Emit update
      this.emitUpdate();
    });
  }

  protected emitUpdate(): void {
    logger.labeledLog('Emit update event');
    this.emit('update');
  }

  async startObserve(): Promise<void> {
    this.enableObserver();

    // Switch observer on visibility changed
    document.addEventListener('visibilitychange', () => {
      switch (document.visibilityState) {
        case 'visible':
          logger.labeledLog('Changed visibility to [visible] state');
          this.emitUpdate();
          this.enableObserver();
          break;
        case 'hidden':
          logger.labeledLog('Changed visibility to [hidden] state');
          this.disableObserver();
          break;
        default:
          logger.labeledLog('Changed visibility to [unknown] state');
          this.disableObserver();
          break;
      }
    });

    this.observeWorkspace();
    this.observeWorkspaceWrapperChildren();
  }

  /**
   * Force re-observe on workspace tab changed
   * This is backward compatibility
   */
  protected observeWorkspace(): void {
    const workspace = document.querySelector(domConstants.SELECTOR_WORKSPACE);
    const workspaceObserver = new MutationObserver((): void => {
      logger.labeledLog('Workspace tab changed');

      this.emitUpdate();

      // re-observe
      this.disableObserver();
      this.enableObserver();
    });

    if (!workspace) {
      logger.labeledLog('Workspace element not found');
      return;
    }

    logger.labeledLog('Observe workspace');
    workspaceObserver.observe(workspace, {
      attributes: true,
      attributeFilter: ['aria-label'],
    });
  }

  /**
   * Force re-observe on workspace wrapper children changed
   */
  protected observeWorkspaceWrapperChildren(): void {
    const workspaceWrapper = document.querySelector(domConstants.SELECTOR_WORKSPACE_WRAPPER);
    const workspaceWrapperObserver = new MutationObserver((): void => {
      logger.labeledLog('Workspace wrapper children changed');

      this.emitUpdate();

      // re-observe
      this.disableObserver();
      this.enableObserver();
    });

    if (!workspaceWrapper) {
      logger.labeledLog('Workspace wrapper element not found');
      return;
    }

    logger.labeledLog('Observe workspace wrapper children');
    workspaceWrapperObserver.observe(workspaceWrapper, {
      childList: true,
      // NOTE: If set true, cause infinity loop. b/c observe channel name dom change.
      subtree: false,
    });
  }

  protected enableObserver(): void {
    const channelListContainer = document.querySelector(domConstants.SELECTOR_CHANNEL_LIST_CONTAINER);

    if (this.isObserving) {
      return;
    }

    if (!channelListContainer) {
      return;
    }

    // Observe elements
    this.observeChannelListContainer(channelListContainer);
    document.querySelectorAll(domConstants.SELECTOR_CHANNEL_ITEM_NAME_SELECTOR).forEach((channelListItemElem) => {
      this.observeChannelListItemName(channelListItemElem);
    });

    this.isObserving = true;
  }

  protected disableObserver(): void {
    if (!this.isObserving) {
      return;
    }

    this.channelListObserver.disconnect();
    this.isObserving = false;
  }

  protected observeChannelListContainer(channelListContainerElem: Node): void {
    logger.labeledLog('Observe channel list container');

    this.channelListObserver.observe(channelListContainerElem, {
      childList: true,
      // NOTE: If set true, cause infinity loop. b/c observe channel name dom change.
      subtree: false,
    });
  }

  protected observeChannelListItemName(channelListItemNameElem: Node): void {
    logger.labeledLog('Observe channel list item name');

    this.channelListObserver.observe(channelListItemNameElem, {
      attributes: true,
      attributeFilter: ['data-qa'],
    });
  }
}

================
File: app/scripts/content/dom-constants.ts
================
const SELECTOR_CHANNEL_LIST = '.p-channel_sidebar__static_list';

// selectors
export const SELECTOR_CHANNEL_LIST_CONTAINER = SELECTOR_CHANNEL_LIST + ' .c-virtual_list__scroll_container';
export const SELECTOR_WORKSPACE_WRAPPER = '.p-client_workspace_wrapper';
export const SELECTOR_WORKSPACE = '.p-client_workspace';
export const SELECTOR_CHANNEL_LIST_ITEMS =
  SELECTOR_CHANNEL_LIST + ' [role=listitem], ' + SELECTOR_CHANNEL_LIST + ' [role=treeitem]';
export const SELECTOR_CHANNEL_ITEM_CONTENTS_CONTAINER = '.p-channel_sidebar__channel';
export const SELECTOR_CHANNEL_ITEM_NAME_SELECTOR = '.p-channel_sidebar__name';

// data attr key
export const DATA_KEY_CHANNEL_ITEM_CONTENTS_CONTAINER_CHANNEL_TYPE = 'data-qa-channel-sidebar-channel-type';

// data attr key for extension
export const DATA_KEY_CHANNEL_NAME = 'data-scg-channel-name';

================
File: app/scripts/content/logger.ts
================
import { ConsoleLogger } from './utils/console-logger';

declare let __DEVELOPMENT__: boolean;

export const logger = new ConsoleLogger(
  'slack-ch-group',
  __DEVELOPMENT__ ? ConsoleLogger.levels.TRACE : ConsoleLogger.levels.WARN,
);

================
File: app/scripts/content/utils/console-logger.ts
================
import * as loglevel from 'loglevel';

export class ConsoleLogger {
  public static levels = loglevel.levels;
  private label: string;
  private logger: loglevel.Logger;

  constructor(label: string, logLevel: loglevel.LogLevelDesc) {
    this.label = label;
    this.logger = loglevel.getLogger(label);
    this.logger.setLevel(logLevel);
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  labeledLog(...values: any[]): void {
    this.logger.debug('%c' + this.label, 'background: #67b083; color: #000; padding: 0.2em 0.5em', ...values);
  }
}

================
File: app/scripts/content/utils/extension-running-checker.ts
================
export function isAlreadyRunningExtension(identifier: string): boolean {
  const meta: HTMLMetaElement | null = document.querySelector(`meta[name="${identifier}"]`);

  if (meta) {
    return true;
  }

  // Insert meta to head
  const metaElement: HTMLMetaElement = document.createElement('meta');
  metaElement.name = identifier;
  metaElement.content = 'true';
  document.head.appendChild(metaElement);

  return false;
}

================
File: app/scripts/content/utils/wait-element-render.ts
================
export function waitElementRender(
  elementSelector: string,
  waitRenderInterval: number,
  waitTimeout: number,
): Promise<void> {
  return new Promise((resolve, reject): void => {
    const loopStartTime = Date.now();

    const checkElementLoop = (): void => {
      // Found element
      if (document.querySelectorAll(elementSelector).length > 0) {
        resolve();
        return;
      }

      // Timeout
      if (Date.now() - loopStartTime > waitTimeout) {
        reject();
        return;
      }

      window.setTimeout(checkElementLoop, waitRenderInterval);
    };

    checkElementLoop();
  });
}

================
File: app/scripts/content.ts
================
import ChannelObserver from './content/channel-observer';
import ChannelGrouper from './content/channel-grouper';
import { waitElementRender } from './content/utils/wait-element-render';
import * as domConstants from './content/dom-constants';
import { logger } from './content/logger';
import { isAlreadyRunningExtension } from './content/utils/extension-running-checker';
import { DomChannelManipulator } from './content/channel-manipulators/dom-channel-manipulator';

const RUNNING_CHECK_IDENTIFIER = 'slack-channels-grouping';
const WAIT_RENDER_CHANNEL_LIST_TIMEOUT = 1000 * 60;
const WAIT_RENDER_CHANNEL_LIST_INTERVAL = 200;

((): void => {
  waitElementRender(
    domConstants.SELECTOR_CHANNEL_LIST_ITEMS,
    WAIT_RENDER_CHANNEL_LIST_INTERVAL,
    WAIT_RENDER_CHANNEL_LIST_TIMEOUT,
  )
    .then(() => {
      // Check already running extension
      if (isAlreadyRunningExtension(RUNNING_CHECK_IDENTIFIER)) {
        logger.labeledLog('Extension is already running. Skip apply.');
        return;
      }

      logger.labeledLog('Rendered channel list item.');

      const channelObserver = new ChannelObserver();
      const domChannnelManipulator = new DomChannelManipulator();
      const channelGrouper = new ChannelGrouper(domChannnelManipulator);

      // Grouping
      channelGrouper.groupingOnIdleAndDebounce();

      // Grouping on update
      channelObserver.on('update', () => {
        channelGrouper.groupingOnIdleAndDebounce();
      });

      channelObserver.startObserve();
    })
    .catch(() => {
      logger.labeledLog('Fail to wait channel list item.');
      // Do nothing
    });
})();

================
File: app/scripts/popup/App.tsx
================
import React from 'react';
import { useWorkspace } from './hooks/useWorkspace';
import WorkspaceSettings from './components/WorkspaceSettings';
import InvalidPageMessage from './components/InvalidPageMessage';

const App: React.FC = () => {
  const { workspaceId, isLoading, error } = useWorkspace();

  if (isLoading) {
    return <div className="bg-white text-gray-800 p-4 w-100">Loading...</div>;
  }

  return (
    <div className="bg-white text-gray-800 p-3 w-100">
      <div className="text-lg font-bold mb-3 text-gray-900 flex items-center justify-center">
        <img src="../../images/icon-19.png" alt="slack-icon" className="mr-2" />
        <h1 className="inline-block">Slack Channel Grouping</h1>
      </div>

      {(error || !workspaceId) ? (
        <InvalidPageMessage />
      ) : (
        <WorkspaceSettings workspaceId={workspaceId} />
      )}
    </div>
  );
};

export default App;

================
File: app/scripts/popup/components/InvalidPageMessage.tsx
================
import React from 'react';

const InvalidPageMessage: React.FC = () => (
  <div className="bg-gray-100 border-l-4 border-gray-300 p-4 rounded-md" role="alert">
    <p className="text-gray-800">This extension works only for Slack.</p>
    <a
      href="https://app.slack.com/"
      target="_blank"
      rel="noopener noreferrer"
      className="text-blue-600 hover:underline mt-2 inline-block"
    >
      app.slack.com
    </a>
  </div>
);

export default InvalidPageMessage;

================
File: app/scripts/popup/components/MultiLevelGroupingToggle.tsx
================
import React from 'react';

interface MultiLevelGroupingToggleProps {
  isEnabled: boolean;
  onToggle: (enabled: boolean) => void;
}

const MultiLevelGroupingToggle: React.FC<MultiLevelGroupingToggleProps> = ({ isEnabled, onToggle }) => {
  return (
    <div className="flex items-center justify-between">
      <span className="flex flex-grow flex-col">
        <span className="text-sm font-medium text-gray-900">Multi-level Grouping</span>
        <span className="text-sm text-gray-500">
          Enable grouping for multiple levels of channel prefixes
        </span>
      </span>
      <button
        onClick={() => onToggle(!isEnabled)}
        className={`${
          isEnabled ? 'bg-indigo-600' : 'bg-gray-200'
        } relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2`}
      >
        <span
          className={`${
            isEnabled ? 'translate-x-5' : 'translate-x-0'
          } pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out`}
        />
      </button>
    </div>
  );
};

export default MultiLevelGroupingToggle;

================
File: app/scripts/popup/components/RegexSettings.tsx
================
import React, { useState, useEffect } from 'react';
import { CheckIcon } from '@heroicons/react/24/solid';

interface RegexSettingsProps {
  onApply: () => void;
}

const RegexSettings: React.FC<RegexSettingsProps> = ({ onApply }) => {
  const [inputRegex, setInputRegex] = useState('');
  const [isApplied, setIsApplied] = useState(false);
  const [isChanged, setIsChanged] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    loadRegexFromStorage();
  }, []);

  const loadRegexFromStorage = () => {
    chrome.storage.local.get(['regexPattern'], (result) => {
      if (result.regexPattern) {
        setInputRegex(result.regexPattern);
      }
    });
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    chrome.storage.local.set({ regexPattern: inputRegex }, () => {
      if (chrome.runtime.lastError) {
        console.error('Error saving regex:', chrome.runtime.lastError);
        setError('Failed to save changes. Please try again.');
      } else {
        chrome.runtime.sendMessage({ action: 'settingsUpdated' }, (response) => {
          if (chrome.runtime.lastError) {
            console.error('Error notifying content script:', chrome.runtime.lastError);
            setError('Failed to apply changes. Please try again.');
          } else {
            setIsApplied(true);
            setIsChanged(false);
            onApply();
            setTimeout(() => setIsApplied(false), 1000);
          }
        });
      }
    });
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value;
    setInputRegex(newValue);
    setIsChanged(true);
  };

  const buttonText = isApplied ? 'Applied!' : 'Apply Changes';

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <label className="block text-xs font-medium mb-1 text-gray-700">
          Channel Prefix Regex
        </label>
        <div className="text-xs text-gray-500 mb-1"><span className="text-xs text-gray-500">Default: <code className="bg-gray-100 p-1 rounded-sm text-xs text-purple-600 font-mono">^(.+?)[-_]</code></span></div>
        <input
          type="text"
          value={inputRegex}
          onChange={handleInputChange}
          className="w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          placeholder="Enter regex pattern"
        />
      </div>
      <button
        type="submit"
        disabled={!isChanged || isApplied}
        className={`w-full p-2 rounded-md flex items-center justify-center ${
          isChanged && !isApplied
            ? 'bg-green-600 text-white hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2'
            : 'bg-gray-300 text-gray-500 cursor-not-allowed'
        }`}
      >
        <CheckIcon className="h-5 w-5 mr-2" />
        <span>{buttonText}</span>
      </button>
      {error && <p className="text-red-500 text-sm">{error}</p>}
    </form>
  );
};

export default RegexSettings;

================
File: app/scripts/popup/components/WorkspaceSettings.tsx
================
import React from 'react';
import MultiLevelGroupingToggle from './MultiLevelGroupingToggle';
import { useWorkspaceSettings } from '../hooks/useWorkspaceSettings';

interface WorkspaceSettingsProps {
  workspaceId: string;
}

const WorkspaceSettings: React.FC<WorkspaceSettingsProps> = ({ workspaceId }) => {
  const { settings, updateSettings } = useWorkspaceSettings(workspaceId);

  return (
    <div>
      <h2 className="text-base font-semibold mb-2 text-gray-700 border-l-4 border-gray-300 pl-2 py-1">Workspace Settings</h2>
      <div className="mb-2">
        <div className="bg-gray-100 p-2 rounded-md text-gray-700">
          {`app.slack.com/${workspaceId}`}
        </div>
      </div>
      <MultiLevelGroupingToggle
        isEnabled={settings.multiLevelGrouping}
        onToggle={(enabled) => updateSettings({ multiLevelGrouping: enabled })}
      />
    </div>
  );
};

export default WorkspaceSettings;

================
File: app/scripts/popup/hooks/useWorkspace.ts
================
import { useState, useEffect } from 'react';

export const useWorkspace = () => {
  const [workspaceId, setWorkspaceId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const getWorkspaceId = () => {
      chrome.tabs.query({active: true, currentWindow: true}, (tabs) => {
        const currentTab = tabs[0];
        if (!currentTab || !currentTab.url) {
          setError('Unable to access current tab');
          setIsLoading(false);
          return;
        }

        const match = currentTab.url.match(/https:\/\/app\.slack\.com\/client\/([^/]+)/);
        if (match && match[1]) {
          setWorkspaceId(match[1]);
        } else {
          setError('Not a valid Slack workspace page');
        }
        setIsLoading(false);
      });
    };

    getWorkspaceId();
  }, []);

  return { workspaceId, isLoading, error };
};

================
File: app/scripts/popup/hooks/useWorkspaceSettings.ts
================
import { useState, useEffect } from 'react';

interface WorkspaceSettings {
  multiLevelGrouping: boolean;
}

export const useWorkspaceSettings = (workspaceId: string) => {
  const [settings, setSettings] = useState<WorkspaceSettings>({
    multiLevelGrouping: false,
  });

  useEffect(() => {
    // Load settings from storage
    chrome.storage.local.get([workspaceId], (result) => {
      if (result[workspaceId]) {
        setSettings(result[workspaceId]);
      }
    });
  }, [workspaceId]);

  const updateSettings = (newSettings: Partial<WorkspaceSettings>) => {
    const updatedSettings = { ...settings, ...newSettings };
    setSettings(updatedSettings);
    chrome.storage.local.set({ [workspaceId]: updatedSettings }, () => {
      chrome.runtime.sendMessage({ action: 'settingsUpdated' });
    });
  };

  return { settings, updateSettings };
};

================
File: app/scripts/popup/index.tsx
================
import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';
import '../../styles/popup.pcss';

const container = document.getElementById('root');
if (!container) throw new Error('Failed to find the root element');
const root = createRoot(container);

root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

================
File: app/styles/content.css
================
.scg-ch-prefix {
  font-weight: normal;
}

.scg-ch-child .scg-ch-prefix {
  opacity: 0;
}

.scg-ch-separator {
  margin: 0 .2em 0 .1em;
  font-weight: 400;
  transform: scale(1.0, 1.5);
  display: inline-block;
  font-family: "SlackChannelsGrounping-NotoSansJP-Medium", monospace;
  -webkit-font-smoothing: none;
  -moz-osx-font-smoothing: unset;
  position: relative;
}

.scg-ch-separator:before {
  content: "│";
  font-family: "SlackChannelsGrounping-NotoSansJP-Medium", monospace;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}
.scg-ch-separator.scg-ch-separator-pseudo-top:before {
  top: -10px;
}
.scg-ch-separator.scg-ch-separator-pseudo-bottom:before {
  top: 10px;
}
.scg-ch-separator.scg-ch-separator-pseudo-both:before {
  top: 0;
  transform: scale(1.0, 1.5);
}

.scg-ch-name {}

================
File: app/styles/font-face-firefox.css
================
@font-face {
  font-family: 'SlackChannelsGrounping-NotoSansJP-Medium';
  src: url('moz-extension://__MSG_@@extension_id__/fonts/SlackChannelsGrounping-NotoSansJP-Medium.ttf') format('truetype');
  font-weight: normal;
  font-style: normal;
}

================
File: app/styles/font-face.css
================
@font-face {
  font-family: 'SlackChannelsGrounping-NotoSansJP-Medium';
  src: url('chrome-extension://__MSG_@@extension_id__/fonts/SlackChannelsGrounping-NotoSansJP-Medium.ttf') format('truetype');
  font-weight: normal;
  font-style: normal;
}

================
File: app/styles/popup.pcss
================
@tailwind base;
@tailwind components;
@tailwind utilities;

html, body {
  max-width: 315px;
  min-width: 280px;
}

.root {
  width: 100%;
  height: 100%;
}

img {
  image-rendering: pixelated;
image-rendering: -moz-crisp-edges;

}

================
File: eslint.config.mjs
================
import js from '@eslint/js';
import typescriptEslintParser from '@typescript-eslint/parser';
import typescriptEslint from '@typescript-eslint/eslint-plugin';
import importPlugin from 'eslint-plugin-import';
import eslintPluginPrettier from 'eslint-plugin-prettier';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';

export default [
  {
    files: ['**/*.ts'],
    languageOptions: {
      globals: {
        ...globals.es2021,
        ...globals.browser,
        ...globals.webextensions,
      },
      parser: typescriptEslintParser,
    },
    plugins: {
      'js': js,
      '@typescript-eslint': typescriptEslint,
      'import': importPlugin,
      'prettier': eslintPluginPrettier,
    },
    rules: {
      ...js.configs.recommended.rules,
      'no-undef': 'off',

      ...typescriptEslint.configs.recommended.rules,
      ...typescriptEslint.configs.strict.rules,
      ...typescriptEslint.configs.stylistic.rules,
      '@typescript-eslint/no-var-requires': 'off',

      ...importPlugin.configs.typescript.rules,
      'import/no-unresolved': 'off',
      'import/prefer-default-export': 'off',

      ...eslintPluginPrettierRecommended.rules,
      'prettier/prettier': 'warn',
    },
  },
];

================
File: package.json
================
{
  "name": "slack-channel-grouping",
  "version": "0.0.0",
  "description": "Grouping Slack channels by prefix",
  "main": "",
  "scripts": {
    "dev": "webextension-toolbox dev",
    "build": "webextension-toolbox build",
    "lint": "eslint ./app --max-warnings 0 --cache --format friendly",
    "lint:fix": "yarn lint --fix",
    "test": "vitest --dom",
    "supported-browsers": "yarn browserslist",
    "archive": "git archive HEAD -o storage/source.zip",
    "type-check": "tsc --noEmit",
    "renovate-validate": "renovate-config-validator",
    "preinstall": "typesync || :"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/yamadashy/slack-channels-grouping.git"
  },
  "keywords": [
    "chrome",
    "extension",
    "firefox",
    "addon",
    "slack",
    "channel",
    "grouping"
  ],
  "author": "yamadashy",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/yamadashy/slack-channels-grouping/issues"
  },
  "dependencies": {
    "core-js": "3.37.1",
    "eventemitter3": "5.0.1",
    "jquery": "3.7.1",
    "loglevel": "^1.8.1",
    "requestidlecallback-polyfill": "1.0.2"
  },
  "devDependencies": {
    "@babel/cli": "^7.23.4",
    "@babel/core": "^7.23.6",
    "@babel/plugin-proposal-class-properties": "^7.18.6",
    "@babel/plugin-proposal-object-rest-spread": "^7.20.7",
    "@babel/preset-env": "^7.23.6",
    "@babel/preset-typescript": "^7.23.3",
    "@eslint/js": "^9.3.0",
    "@heroicons/react": "^2.1.5",
    "@types/babel__core": "^7.20.5",
    "@types/babel__preset-env": "^7.9.6",
    "@types/chrome": "^0.0.268",
    "@types/core-js": "2.5.8",
    "@types/eslint": "^8.56.0",
    "@types/eslint-config-prettier": "^6.11.3",
    "@types/eslint-plugin-prettier": "^3.1.3",
    "@types/eslint__js": "~8.42.3",
    "@types/jquery": "^3.5.29",
    "@types/prettier": "^3.0.0",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "@types/webpack-bundle-analyzer": "^4.6.3",
    "@typescript-eslint/eslint-plugin": "^7.0.0",
    "@typescript-eslint/parser": "^7.0.0",
    "@webextension-toolbox/webextension-toolbox": "^7.0.0",
    "autoprefixer": "^10.4.19",
    "babel-loader": "^9.1.3",
    "css-loader": "^7.1.2",
    "eslint": "^9.0.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-formatter-friendly": "^7.0.0",
    "eslint-plugin-import": "^2.29.1",
    "eslint-plugin-prettier": "^5.1.1",
    "globals": "^15.2.0",
    "happy-dom": "^14.12.3",
    "mini-css-extract-plugin": "^2.9.0",
    "postcss": "^8.4.39",
    "postcss-loader": "^8.1.1",
    "prettier": "^3.1.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "renovate": "^37.326.2",
    "style-loader": "^4.0.0",
    "tailwindcss": "^3.4.4",
    "typescript": "^5.3.3",
    "typesync": "^0.12.0",
    "vitest": "^1.6.0",
    "webpack-bundle-analyzer": "^4.10.1"
  },
  "babel": {
    "presets": [
      [
        "@babel/preset-env",
        {
          "useBuiltIns": "usage",
          "corejs": 3
        }
      ]
    ],
    "plugins": [
      "@babel/proposal-class-properties",
      "@babel/proposal-object-rest-spread"
    ]
  },
  "browserslist": [
    "last 2 versions, not dead, > 0.2%"
  ],
  "prettier": {
    "tabWidth": 2,
    "semi": true,
    "singleQuote": true,
    "printWidth": 120,
    "bracketSpacing": true,
    "trailingComma": "all",
    "quoteProps": "consistent"
  },
  "engines": {
    "node": ">=18",
    "yarn": ">=4.0.0"
  },
  "packageManager": "yarn@4.3.1"
}

================
File: postcss.config.js
================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: renovate.json
================
{
  "$schema": "https://docs.renovatebot.com/renovate-schema.json",
  "extends": [
    "config:recommended"
  ],
  "schedule": [
    "every weekend"
  ],
  "timezone": "Asia/Tokyo",
  "dependencyDashboard": false,
  "automerge": true,
  "branchConcurrentLimit": 0,
  "prHourlyLimit": 0,
  "labels": ["dependencies", "renovate"],
  "packageRules": [
    {
      "matchUpdateTypes": ["patch", "minor"],
      "groupName": "minor and patch dependencies",
      "automerge": true
    },
    {
      "matchUpdateTypes": ["major"],
      "groupName": "major dependencies",
      "automerge": false
    },
    {
      "matchPackageNames": ["renovate"],
      "enabled": false
    }
  ]
}

================
File: repopack.config.mjs
================
/** @type {import('repopack').RepopackConfig} */
const config = {
  output: {
    filePath: 'custom-output.txt',
    headerText: 'Wow!',
  },
  ignore: {
    useDefaultPatterns: true,
    customPatterns: ['additional-folder', '*.log'],
  },
};

export default config;

================
File: resources/dictionaries/slack-channels-grouping.dic
================
treeitem
listitem
visibilitychange

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.html',
    './app/**/*.ts',
    './app/**/*.tsx',
    './app/**/*.js',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}

================
File: tests/channel-grouper.test.ts
================
import { describe, it, expect } from 'vitest';
import ChannelGrouper from '../app/scripts/content/channel-grouper';
import {
  ChannelItemContext,
  ChannelItemContextGroupType,
  ChannelManipulator,
  GroupedChannelItemContext,
} from '../app/scripts/content/channel-manipulators/channel-manipulator';

class MockChannelManipulator implements ChannelManipulator {
  private channels: ChannelItemContext[] = [];
  private groupedChannels: GroupedChannelItemContext[] = [];

  getChannelItemContexts(): ChannelItemContext[] {
    return this.channels;
  }

  persistGroupedChannelItemContexts(channelItemContexts: GroupedChannelItemContext[]): void {
    this.groupedChannels = channelItemContexts;
  }

  updateChannelItems(channelItemContexts: GroupedChannelItemContext[]): void {
    this.groupedChannels = channelItemContexts;
  }

  getGroupedChannelItemContexts(): GroupedChannelItemContext[] {
    return this.groupedChannels;
  }

  setChannels(channels: ChannelItemContext[]): void {
    this.channels = channels;
  }
}

describe('ChannelGrouper test with multiple scenarios', () => {
  const testCases: {
    name: string;
    channels: ChannelItemContext[];
    expected: Partial<GroupedChannelItemContext>[];
  }[] = [
    {
      name: 'only one channel',
      channels: [{ index: 0, name: 'general', channelItemType: 'channel' }],
      expected: [{ prefix: null, groupType: ChannelItemContextGroupType.Alone }],
    },
    {
      name: 'should group channels correctly with various patterns',
      channels: [
        { index: 0, name: 'general', channelItemType: 'channel' },
        { index: 1, name: 'prefix-aaa', channelItemType: 'channel' },
        { index: 2, name: 'prefix-bbb', channelItemType: 'channel' },
        { index: 3, name: 'prefix-ccc', channelItemType: 'channel' },
        { index: 4, name: 'another-xxx', channelItemType: 'channel' },
        { index: 5, name: 'another-yyy', channelItemType: 'channel' },
        { index: 6, name: 'solo-aaa', channelItemType: 'channel' },
        { index: 7, name: 'random', channelItemType: 'channel' },
      ],
      expected: [
        { prefix: null, groupType: ChannelItemContextGroupType.Alone },
        { prefix: 'prefix', groupType: ChannelItemContextGroupType.Parent },
        { prefix: 'prefix', groupType: ChannelItemContextGroupType.Child },
        { prefix: 'prefix', groupType: ChannelItemContextGroupType.LastChild },
        { prefix: 'another', groupType: ChannelItemContextGroupType.Parent },
        { prefix: 'another', groupType: ChannelItemContextGroupType.LastChild },
        { prefix: 'solo', groupType: ChannelItemContextGroupType.Alone },
        { prefix: null, groupType: ChannelItemContextGroupType.Alone },
      ],
    },
    {
      name: 'should handle all channels without prefix',
      channels: [
        { index: 0, name: 'general', channelItemType: 'channel' },
        { index: 1, name: 'random', channelItemType: 'channel' },
        { index: 2, name: 'announcements', channelItemType: 'channel' },
      ],
      expected: [
        { prefix: null, groupType: ChannelItemContextGroupType.Alone },
        { prefix: null, groupType: ChannelItemContextGroupType.Alone },
        { prefix: null, groupType: ChannelItemContextGroupType.Alone },
      ],
    },
    {
      name: 'should handle single group correctly',
      channels: [
        { index: 0, name: 'prefix-aaa', channelItemType: 'channel' },
        { index: 1, name: 'prefix-bbb', channelItemType: 'channel' },
      ],
      expected: [
        { prefix: 'prefix', groupType: ChannelItemContextGroupType.Parent },
        { prefix: 'prefix', groupType: ChannelItemContextGroupType.LastChild },
      ],
    },
    {
      name: 'should handle multiple different prefixes',
      channels: [
        { index: 0, name: 'a-1', channelItemType: 'channel' },
        { index: 1, name: 'b-1', channelItemType: 'channel' },
        { index: 2, name: 'c-1', channelItemType: 'channel' },
        { index: 3, name: 'a-2', channelItemType: 'channel' },
      ],
      expected: [
        { prefix: 'a', groupType: ChannelItemContextGroupType.Alone },
        { prefix: 'b', groupType: ChannelItemContextGroupType.Alone },
        { prefix: 'c', groupType: ChannelItemContextGroupType.Alone },
        { prefix: 'a', groupType: ChannelItemContextGroupType.Alone },
      ],
    },
    {
      name: 'should handle mix of prefixed and non-prefixed channels',
      channels: [
        { index: 0, name: 'general', channelItemType: 'channel' },
        { index: 1, name: 'a-1', channelItemType: 'channel' },
        { index: 2, name: 'a-2', channelItemType: 'channel' },
        { index: 3, name: 'random', channelItemType: 'channel' },
      ],
      expected: [
        { prefix: null, groupType: ChannelItemContextGroupType.Alone },
        { prefix: 'a', groupType: ChannelItemContextGroupType.Parent },
        { prefix: 'a', groupType: ChannelItemContextGroupType.LastChild },
        { prefix: null, groupType: ChannelItemContextGroupType.Alone },
      ],
    },
    {
      name: 'should handle single channel groups (Alone cases)',
      channels: [
        { index: 0, name: 'a-1', channelItemType: 'channel' },
        { index: 1, name: 'b-1', channelItemType: 'channel' },
        { index: 2, name: 'c-1', channelItemType: 'channel' },
      ],
      expected: [
        { prefix: 'a', groupType: ChannelItemContextGroupType.Alone },
        { prefix: 'b', groupType: ChannelItemContextGroupType.Alone },
        { prefix: 'c', groupType: ChannelItemContextGroupType.Alone },
      ],
    },
    {
      name: 'should handle prefixes starting with numbers',
      channels: [
        { index: 0, name: '1-project-a', channelItemType: 'channel' },
        { index: 1, name: '1-project-b', channelItemType: 'channel' },
        { index: 2, name: '2-project-a', channelItemType: 'channel' },
      ],
      expected: [
        { prefix: '1', groupType: ChannelItemContextGroupType.Parent },
        { prefix: '1', groupType: ChannelItemContextGroupType.LastChild },
        { prefix: '2', groupType: ChannelItemContextGroupType.Alone },
      ],
    },
    {
      name: 'should handle prefixes with special characters',
      channels: [
        { index: 0, name: 'a_b-1', channelItemType: 'channel' },
        { index: 1, name: 'a_b-2', channelItemType: 'channel' },
        { index: 2, name: 'a.c-1', channelItemType: 'channel' },
      ],
      expected: [
        { prefix: 'a', groupType: ChannelItemContextGroupType.Parent },
        { prefix: 'a', groupType: ChannelItemContextGroupType.LastChild },
        { prefix: 'a.c', groupType: ChannelItemContextGroupType.Alone },
      ],
    },
    {
      name: 'should handle very long channel names',
      channels: [
        { index: 0, name: 'very-long-prefix-'.repeat(10) + '1', channelItemType: 'channel' },
        { index: 1, name: 'very-long-prefix-'.repeat(10) + '2', channelItemType: 'channel' },
      ],
      expected: [
        { prefix: 'very', groupType: ChannelItemContextGroupType.Parent },
        { prefix: 'very', groupType: ChannelItemContextGroupType.LastChild },
      ],
    },
    {
      name: 'should handle large number of channels',
      channels: Array.from({ length: 1000 }, (_, i) => ({
        index: i,
        name: `prefix-${i}`,
        channelItemType: 'channel',
      })),
      expected: [
        { prefix: 'prefix', groupType: ChannelItemContextGroupType.Parent },
        ...Array(998).fill({ prefix: 'prefix', groupType: ChannelItemContextGroupType.Child }),
        { prefix: 'prefix', groupType: ChannelItemContextGroupType.LastChild },
      ],
    },
    {
      name: 'should group channels with same prefix regardless of different structure',
      channels: [
        { index: 0, name: 'prefix-a', channelItemType: 'channel' },
        { index: 1, name: 'prefix-b-c', channelItemType: 'channel' },
      ],
      expected: [
        { prefix: 'prefix', groupType: ChannelItemContextGroupType.Parent },
        { prefix: 'prefix', groupType: ChannelItemContextGroupType.LastChild },
      ],
    },
    {
      name: 'should handle empty channel list',
      channels: [],
      expected: [],
    },
    {
      name: 'should group channels with including im channels',
      channels: [
        { index: 0, name: 'prefix-a', channelItemType: 'channel' },
        { index: 1, name: 'im-1', channelItemType: 'im' },
        { index: 2, name: 'im-2', channelItemType: 'im' },
        { index: 3, name: 'prefix-b-c', channelItemType: 'channel' },
        { index: 4, name: 'prefix-b-d', channelItemType: 'channel' },
        { index: 5, name: 'mpim-1', channelItemType: 'mpim' },
        { index: 6, name: 'mpim-2', channelItemType: 'mpim' },
        { index: 7, name: 'prefix-b-c', channelItemType: 'channel' },
      ],
      expected: [
        { prefix: 'prefix', groupType: ChannelItemContextGroupType.Alone },
        { prefix: null, groupType: ChannelItemContextGroupType.Alone },
        { prefix: null, groupType: ChannelItemContextGroupType.Alone },
        { prefix: 'prefix', groupType: ChannelItemContextGroupType.Parent },
        { prefix: 'prefix', groupType: ChannelItemContextGroupType.LastChild },
        { prefix: null, groupType: ChannelItemContextGroupType.Alone },
        { prefix: null, groupType: ChannelItemContextGroupType.Alone },
        { prefix: 'prefix', groupType: ChannelItemContextGroupType.Alone },
      ],
    },
    {
      name: 'should handle realistic channel grouping scenario',
      channels: [
        { index: 0, name: 'a-b-c-a', channelItemType: 'channel' },
        { index: 1, name: 'a-b-c-a-c', channelItemType: 'channel' },
        { index: 2, name: 'chat-cat-c', channelItemType: 'channel' },
        { index: 3, name: 'chat-dog-ed', channelItemType: 'channel' },
        { index: 4, name: 'chat-game', channelItemType: 'channel' },
        { index: 5, name: 'chat-lunch', channelItemType: 'channel' },
        { index: 6, name: 'dev-extension', channelItemType: 'channel' },
        { index: 7, name: 'dev-readme', channelItemType: 'channel' },
        { index: 8, name: 'dev-todo', channelItemType: 'channel' },
        { index: 9, name: 'feed-tech-blog', channelItemType: 'channel' },
        { index: 10, name: 'feed-twitter', channelItemType: 'channel' },
        { index: 11, name: 'general', channelItemType: 'channel' },
        { index: 12, name: 'timeline', channelItemType: 'channel' },
        { index: 13, name: 'zzz-aaa', channelItemType: 'channel' },
        { index: 14, name: 'zzz-aac', channelItemType: 'channel' },
        { index: 15, name: 'zzz-aab', channelItemType: 'channel' },
      ],
      expected: [
        { prefix: 'a', groupType: ChannelItemContextGroupType.Parent },
        { prefix: 'a', groupType: ChannelItemContextGroupType.LastChild },
        { prefix: 'chat', groupType: ChannelItemContextGroupType.Parent },
        { prefix: 'chat', groupType: ChannelItemContextGroupType.Child },
        { prefix: 'chat', groupType: ChannelItemContextGroupType.Child },
        { prefix: 'chat', groupType: ChannelItemContextGroupType.LastChild },
        { prefix: 'dev', groupType: ChannelItemContextGroupType.Parent },
        { prefix: 'dev', groupType: ChannelItemContextGroupType.Child },
        { prefix: 'dev', groupType: ChannelItemContextGroupType.LastChild },
        { prefix: 'feed', groupType: ChannelItemContextGroupType.Parent },
        { prefix: 'feed', groupType: ChannelItemContextGroupType.LastChild },
        { prefix: null, groupType: ChannelItemContextGroupType.Alone },
        { prefix: null, groupType: ChannelItemContextGroupType.Alone },
        { prefix: 'zzz', groupType: ChannelItemContextGroupType.Parent },
        { prefix: 'zzz', groupType: ChannelItemContextGroupType.Child },
        { prefix: 'zzz', groupType: ChannelItemContextGroupType.LastChild },
      ],
    },
  ];

  testCases.forEach(({ name, channels, expected }) => {
    it(name, () => {
      const mockManipulator = new MockChannelManipulator();
      const channelGrouper = new ChannelGrouper(mockManipulator);

      mockManipulator.setChannels(channels);
      const result = channelGrouper.grouping();

      expect(result).not.toBeNull();
      if (result) {
        expect(result.length).toBe(expected.length);
        result.forEach((channel, index) => {
          expect(channel.prefix).toBe(expected[index].prefix);
          expect(channel.groupType).toBe(expected[index].groupType);
        });
      }
    });
  });
});

================
File: tools/font-builder/OFL.txt
================
Copyright 2012 Google Inc. All Rights Reserved.

This Font Software is licensed under the SIL Open Font License, Version 1.1.
This license is copied below, and is also available with a FAQ at:
http://scripts.sil.org/OFL


-----------------------------------------------------------
SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
-----------------------------------------------------------

PREAMBLE
The goals of the Open Font License (OFL) are to stimulate worldwide
development of collaborative font projects, to support the font creation
efforts of academic and linguistic communities, and to provide a free and
open framework in which fonts may be shared and improved in partnership
with others.

The OFL allows the licensed fonts to be used, studied, modified and
redistributed freely as long as they are not sold by themselves. The
fonts, including any derivative works, can be bundled, embedded, 
redistributed and/or sold with any software provided that any reserved
names are not used by derivative works. The fonts and derivatives,
however, cannot be released under any other type of license. The
requirement for fonts to remain under this license does not apply
to any document created using the fonts or their derivatives.

DEFINITIONS
"Font Software" refers to the set of files released by the Copyright
Holder(s) under this license and clearly marked as such. This may
include source files, build scripts and documentation.

"Reserved Font Name" refers to any names specified as such after the
copyright statement(s).

"Original Version" refers to the collection of Font Software components as
distributed by the Copyright Holder(s).

"Modified Version" refers to any derivative made by adding to, deleting,
or substituting -- in part or in whole -- any of the components of the
Original Version, by changing formats or by porting the Font Software to a
new environment.

"Author" refers to any designer, engineer, programmer, technical
writer or other person who contributed to the Font Software.

PERMISSION & CONDITIONS
Permission is hereby granted, free of charge, to any person obtaining
a copy of the Font Software, to use, study, copy, merge, embed, modify,
redistribute, and sell modified and unmodified copies of the Font
Software, subject to the following conditions:

1) Neither the Font Software nor any of its individual components,
in Original or Modified Versions, may be sold by itself.

2) Original or Modified Versions of the Font Software may be bundled,
redistributed and/or sold with any software, provided that each copy
contains the above copyright notice and this license. These can be
included either as stand-alone text files, human-readable headers or
in the appropriate machine-readable metadata fields within text or
binary files as long as those fields can be easily viewed by the user.

3) No Modified Version of the Font Software may use the Reserved Font
Name(s) unless explicit written permission is granted by the corresponding
Copyright Holder. This restriction only applies to the primary font name as
presented to the users.

4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font
Software shall not be used to promote, endorse or advertise any
Modified Version, except to acknowledge the contribution(s) of the
Copyright Holder(s) and the Author(s) or with their explicit written
permission.

5) The Font Software, modified or unmodified, in part or in whole,
must be distributed entirely under this license, and must not be
distributed under any other license. The requirement for fonts to
remain under this license does not apply to any document created
using the Font Software.

TERMINATION
This license becomes null and void if any of the above conditions are
not met.

DISCLAIMER
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
OTHER DEALINGS IN THE FONT SOFTWARE.

================
File: tools/font-builder/build.sh
================
#!/bin/bash

# https://fonts.google.com/noto/specimen/Noto+Sans+JP

pyftsubset NotoSansJP-Medium.ttf \
  --text=┬└├│ \
  --layout-features="*" \
  --output-file=SlackChannelsGrounping-NotoSansJP-Medium.ttf

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "jsx": "react",
    "strict": true,
    "target": "esnext",
    "module": "commonjs",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "lib": [
      "dom",
      "esnext"
    ],
    "allowJs": false,
    "noImplicitAny": true,
    "removeComments": true,
    "skipLibCheck": true,
    "sourceMap": true
  }
}

================
File: vite.config.ts
================
import { defineConfig } from 'vite';

export default defineConfig({
  test: {
    globals: true,
    environment: 'happy-dom',
    include: ['tests/**/*.test.ts'],
  },
  define: {
    __DEVELOPMENT__: true,
  },
});

================
File: webextension-toolbox.config.js
================
'use strict';

const path = require('path');
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
const { DefinePlugin } = require('webpack');

module.exports = {
  webpack: (config, { vendor }) => {
    // NOTE: This is a workaround for this issue.
    // @see https://github.com/webextension-toolbox/webextension-toolbox/issues/882
    const isDev = process.argv.includes('dev');
    const envName = isDev ? 'development' : 'production';

    // Definitions
    config.plugins.push(new DefinePlugin({
      __DEVELOPMENT__: isDev,
    }))

    // BundleAnalyzer
    config.plugins.push(new BundleAnalyzerPlugin({
      openAnalyzer: false,
      analyzerMode: 'static',
      reportFilename: __dirname + '/storage/bundle-analyzer/' + vendor + '-' + envName + '.html'
    }));

    // css
    config.module.rules.push({
      test: /\.(css|pcss)$/,
      use: [
        'style-loader',
        'css-loader',
        // {
        //   loader: 'css-loader',
        //   options: {
        //     importLoaders: 1,
        //   },
        // },
        'postcss-loader',
      ],
    });

    return config
  },
  copyIgnore: [
    path.resolve('**/*.ts'),
    path.resolve('**/*.tsx'),
    path.resolve('**/*.pcss'),
  ]
};
